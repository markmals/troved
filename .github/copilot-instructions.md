# Contributor Guide

# Deno

## Environment Setup
- Always use Deno 2.x features and APIs
- Use deno.json/deno.jsonc for project configuration
- Never use or create package.json nor tsconfig.json
- Prefer Deno's built-in tools and packages over npm packages when available
- Use the `imports` files in deno.json for dependency management
- Always use explicit file extensions in imports (.ts, .tsx)

## Testing Requirements
- Run `deno task test` for unit tests
- Use Deno's built-in testing framework (Deno.test) for code that doesn't need to be run through the Vite plugin pipeline
- Use Vitest for code that needs to be run through the Vite plugin pipeline, for example React, Solid.js, Astro, or Svelte code
- For JavaScript framework components, use Testing Library (@testing-library/*)
- Ensure all new features include corresponding unit tests
- Mock external APIs

## Code Quality Checks
- Format code with `deno task check` before committing
- Run `deno task check` and fix all info, warnings, and errors
- Type-check with `deno task typecheck`
- Prefer `unknown` over `any` unless absolutely necessary
- Use JSDoc/TSDoc comments for public APIs
- Document important lines of code with a single line comment

## Common Commands
- Dev server: `deno task dev`
- Build: `deno task build`
- Test: `deno task test`
- Type check: `deno task typecheck`
- Lint: `deno task check`

## Import Guidelines
- Use bare specifiers with import map for external deps
- Prefer `jsr:@std/*` for standard library
- Use relative imports for local modules
- Prefer import aliases over relative imports for local modules
- Always include file extensions

## Security Best Practices
- Explicitly specify Deno permissions in scripts
- Never use --allow-all (-A) in production for user scripts (only for npm/jsr packages)
- Validate environment variables at startup using `@std/assert`

## Debugging Approach
- Use console.log with clear prefixes during development
- Check Deno permissions first when encountering errors
- Verify deno.json `imports` configuration for dependency issues

## Deno Issues

If you run into any Deno or Vite related issues that you cannot resolve, use the following commands to try resetting the cache:

```sh
find . -type d -name "node_modules" -exec rm -rf {} + && find . -type f -name "deno.lock" -delete
deno clean
deno install --allow-scripts
```

# React Router

## üö® CRITICAL: Route Type Imports - NEVER MAKE THIS MISTAKE

**THE MOST IMPORTANT RULE: ALWAYS use `./+types/[routeName]` for route type imports.**

```tsx
// ‚úÖ CORRECT - ALWAYS use this pattern:
import type { Route } from "./+types/product-details";
import type { Route } from "./+types/product";
import type { Route } from "./+types/category";

// ‚ùå NEVER EVER use relative paths like this:
// import type { Route } from "../+types/product-details";  // WRONG!
// import type { Route } from "../../+types/product";       // WRONG!
```

**If you see TypeScript errors about missing `./+types/[routeName]` modules:**
1. **IMMEDIATELY run `deno task typecheck`** to generate the types
2. **Or start the dev server** which will auto-generate types
3. **NEVER try to "fix" it by changing the import path**

## Type Generation & Workflow

- **Run `deno task typecheck` after adding/renaming any routes**
- **Run `deno task typecheck` if you see missing type errors**
- Types are auto-generated by `@react-router/dev` in `./+types/[routeName]` relative to each route file
- **The dev server will also generate types automatically**

---

## Critical Package Guidelines

### ‚úÖ CORRECT Packages:
- `react-router` - Main package for routing components and hooks
- `@react-router/dev` - Development tools and route configuration
- `@react-router/node` - Node.js server adapter
- `@react-router/serve` - Production server

### ‚ùå NEVER Use:
- `react-router-dom` - Legacy package, use `react-router` instead
- `@remix-run/*` - Old packages, replaced by `@react-router/*`
- React Router v6 patterns - Completely different architecture

## Essential Framework Architecture

### Route Configuration (`app/routes.ts`)
```tsx
import { type RouteConfig, index, route } from "@react-router/dev/routes";

export default [
  index("routes/home.tsx"),
  route("about", "routes/about.tsx"),
  route("products/:id", "routes/product.tsx", [
    index("routes/product-overview.tsx"),
    route("reviews", "routes/product-reviews.tsx"),
  ]),
  route("categories", "routes/categories-layout.tsx", [
    index("routes/categories-list.tsx"),
    route(":slug", "routes/category-details.tsx"),
  ]),
] satisfies RouteConfig;
```

### Route Module Pattern (`app/routes/product.tsx`)
```tsx
import type { Route } from "./+types/product";

// Server data loading
export async function loader({ params }: Route.LoaderArgs) {
  return { product: await getProduct(params.id) };
}

// Client data loading (when needed)
export async function clientLoader({ serverLoader }: Route.ClientLoaderArgs) {
  // runs on the client and is in charge of calling the loader if one exists via `serverLoader`
  const serverData = await serverLoader();
  return serverData
}

// Form handling
export async function action({ request }: Route.ActionArgs) {
  const formData = await request.formData();
  await updateProduct(formData);
  return redirect(href("/products/:id", { id: params.id }));
}

// Component rendering
export default function Product({ loaderData }: Route.ComponentProps) {
  return <div>{loaderData.product.name}</div>;
}
```

### Layout/Parent Routes with Outlet
**For layout routes that have child routes, ALWAYS use `<Outlet />` to render child routes:**

```tsx
import type { Route } from "./+types/categories-layout";
import { Outlet } from "react-router";

export default function CategoriesLayout(props: Route.ComponentProps) {
  return (
    <div className="layout">
      <nav>
        {/* Sidebar or navigation */}
      </nav>
      <main>
        <Outlet /> {/* ‚úÖ This renders the matching child route */}
      </main>
    </div>
  );
}

// ‚ùå Never use `children` from the component props, it doesn't exist
// export default function CategoriesLayout({ children }: Route.ComponentProps) {


## Automatic Type Safety & Generated Types

**React Router v7 automatically generates types for every route.** These provide complete type safety for loaders, actions, components, and URL generation.

### ‚úÖ ALWAYS Use Generated Types:
Types are autogenerated and should be imported as `./+types/[routeFileName]`. **If you're getting a type error, run `deno task typecheck` first.**

The filename for the autogenerated types is always a relative import of `./+types/[routeFileName]`:

```tsx
// routes.ts
route("products/:id", "routes/product-details.tsx")

// routes/product-details.tsx
// ‚úÖ CORRECT: Import generated types for each route
import type { Route } from "./+types/product-details";

export async function loader({ params }: Route.LoaderArgs) {
  // params.id is automatically typed based on your route pattern
  return { product: await getProduct(params.id) };
}

export default function ProductDetails({ loaderData }: Route.ComponentProps) {
  // loaderData.product is automatically typed from your loader return
  return <div>{loaderData.product.name}</div>;
}
```


### ‚úÖ Type-Safe URL Generation with href():
```tsx
import { Link, href } from "react-router";

// Static routes
<Link to={href("/products/new")}>New Product</Link>

// Dynamic routes with parameters - AUTOMATIC TYPE SAFETY
<Link to={href("/products/:id", { id: product.id })}>View Product</Link>
<Link to={href("/products/:id/edit", { id: product.id })}>Edit Product</Link>

// Works with redirects too
return redirect(href("/products/:id", { id: newProduct.id }));
```

### ‚ùå NEVER Create Custom Route Types:
```tsx
// ‚ùå DON'T create custom type files for routes
export namespace Route {
  export interface LoaderArgs { /* ‚ùå */ }
  export interface ComponentProps { /* ‚ùå */ }
}

// ‚ùå DON'T manually construct URLs - no type safety
<Link to={`/products/${product.id}`}>Product</Link> // ‚ùå
<Link to="/products/" + product.id">Product</Link> // ‚ùå
```

### Type Generation Setup:
- **Location**: Types generated in `./+types/[routeName]` relative to each route file
- **Auto-generated**: Created by `@react-router/dev` when you run dev server or `deno task typecheck`
- **Comprehensive**: Covers `LoaderArgs`, `ActionArgs`, `ComponentProps`, `ErrorBoundaryProps`
- **TypeScript Config**: Add `.react-router/types/**/*` to `include` in `tsconfig.json`

## Critical Imports & Patterns

### ‚úÖ Correct Imports:
```tsx
import { Link, Form, useLoaderData, useFetcher, Outlet } from "react-router";
import { type RouteConfig, index, route } from "@react-router/dev/routes";
import { data, redirect, href } from "react-router";
```

## Data Loading & Actions

### Server vs Client Data Loading:
```tsx
// Server-side rendering and pre-rendering
export async function loader({ params }: Route.LoaderArgs) {
  return { product: await serverDatabase.getProduct(params.id) };
}

// Client-side navigation and SPA mode
export async function clientLoader({ params }: Route.ClientLoaderArgs) {
  return { product: await fetch(`/api/products/${params.id}`).then(r => r.json()) };
}

// Use both together - server for SSR, client for navigation
clientLoader.hydrate = true; // Force client loader during hydration
```

### Form Handling & Actions:
```tsx
// Server action
export async function action({ request }: Route.ActionArgs) {
  const formData = await request.formData();
  const result = await updateProduct(formData);
  return redirect(href("/products"));
}

// Client action (takes priority if both exist)
export async function clientAction({ request }: Route.ClientActionArgs) {
  const formData = await request.formData();
  await apiClient.updateProduct(formData);
  return { success: true };
}

// In component
<Form method="post">
  <input name="name" placeholder="Product name" />
  <input name="price" type="number" placeholder="Price" />
  <button type="submit">Save Product</button>
</Form>
```

## Navigation & Links

### Basic Navigation:
```tsx
import { Link, NavLink } from "react-router";

// Simple links
<Link to="/products">Products</Link>

// Active state styling
<NavLink to="/dashboard" className={({ isActive }) => 
  isActive ? "active" : ""
}>
  Dashboard
</NavLink>

// Programmatic navigation
const navigate = useNavigate();
navigate("/products");
```

### Advanced Navigation with Fetchers:
```tsx
import { useFetcher } from "react-router";

function AddToCartButton({ productId }: { productId: string }) {
  const fetcher = useFetcher();
  
  return (
    <fetcher.Form method="post" action="/api/cart">
      <input type="hidden" name="productId" value={productId} />
      <button type="submit">
        {fetcher.state === "submitting" ? "Adding..." : "Add to Cart"}
      </button>
    </fetcher.Form>
  );
}
```

## File Organization & Naming

### ‚úÖ Flexible File Naming:
React Router v7 uses **explicit route configuration** in `app/routes.ts`. You are NOT constrained by old file-based routing conventions.

```tsx
// ‚úÖ Use descriptive, clear file names
export default [
  route("products", "routes/products-layout.tsx", [
    index("routes/products-list.tsx"),
    route(":id", "routes/product-details.tsx"),
    route(":id/edit", "routes/product-edit.tsx"),
  ]),
] satisfies RouteConfig;
```

### File Naming Best Practices:
- Use **descriptive names** that clearly indicate purpose
- Use **kebab-case** for consistency (`product-details.tsx`)
- Organize by **feature** rather than file naming conventions
- The **route configuration** is the source of truth, not file names

## Error Handling & Boundaries

### Route Error Boundaries:
Only setup `ErrorBoundary`s for routes if the users explicitly asks. All errors bubble up to the `ErrorBoundary` in `root.tsx` by default.

```tsx
export function ErrorBoundary({ error }: Route.ErrorBoundaryProps) {
  if (isRouteErrorResponse(error)) {
    return (
      <div>
        <h1>{error.status} {error.statusText}</h1>
        <p>{error.data}</p>
      </div>
    );
  }
  
  return (
    <div>
      <h1>Oops!</h1>
      <p>{error.message}</p>
    </div>
  );
}
```

### Throwing Errors from Loaders/Actions:
```tsx
export async function loader({ params }: Route.LoaderArgs) {
  const product = await db.getProduct(params.id);
  if (!product) {
    throw data("Product Not Found", { status: 404 });
  }
  return { product };
}
```

## Advanced Patterns

### Pending UI & Optimistic Updates:
```tsx
import { useNavigation, useFetcher } from "react-router";

// Global pending state
function GlobalSpinner() {
  const navigation = useNavigation();
  return navigation.state === "loading" ? <Spinner /> : null;
}

// Optimistic UI with fetchers
function CartItem({ item }) {
  const fetcher = useFetcher();
  const quantity = fetcher.formData 
    ? parseInt(fetcher.formData.get("quantity"))
    : item.quantity;
    
  return (
    <fetcher.Form method="post">
      <input 
        type="number" 
        name="quantity" 
        value={quantity}
        onChange={(e) => fetcher.submit(e.currentTarget.form)}
      />
      {item.product.name}
    </fetcher.Form>
  );
}
```

### Progressive Enhancement:
```tsx
// Works without JavaScript, enhanced with JavaScript
export default function ProductSearchForm() {
  return (
    <Form method="get" action="/products">
      <input type="search" name="q" placeholder="Search products..." />
      <button type="submit">Search</button>
    </Form>
  );
}
```

## Anti-Patterns to Avoid

### ‚ùå React Router v6 Patterns:
```tsx
// DON'T use component routing
<Routes>
  <Route path="/" element={<Home />} />
</Routes>
```

### ‚ùå Manual Data Fetching:
```tsx
// DON'T fetch in components
function Product() {
  const [data, setData] = useState(null);
  useEffect(() => { fetch('/api/products') }, []);
  // Use loader instead!
}
```

### ‚ùå Manual Form Handling:
```tsx
// DON'T handle forms manually
const handleSubmit = (e) => {
  e.preventDefault();
  fetch('/api/products', { method: 'POST' });
};
// Use Form component and action instead!
```

## Essential Type Safety Rules

1. **ALWAYS** import from `"./+types/[routeName]"` - never use relative paths like `"../+types/[routeName]"`
2. **RUN `deno task typecheck`** when you see missing type errors - never try to "fix" the import path
3. **ALWAYS** use `href()` for dynamic URLs - never manually construct route strings  
4. **LET TypeScript infer** loader/action return types - don't over-type returns
5. **USE Route.ComponentProps** for your route components - automatic loaderData typing
6. **ADD** `.react-router/types/**/*` to your `tsconfig.json` include array

## AI Assistant Guidelines

When working with React Router v7:
- **If you see missing `./+types/[routeName]` imports, ALWAYS suggest running `deno task typecheck` first**
- **NEVER suggest changing `./+types/[routeName]` to `../+types/[routeName]` or any other relative path**
- **After creating new routes, remind the user to run `deno task typecheck`**
- **Assume types need to be generated if they're missing, don't assume the dev server is running**

# shadcn/ui

## New UI Components

Use `@withsprinkles/shadcn-ui` for new UI components. `@withsprinkles/shadcn-ui` is a fork of `shadcn-ui` with fixes to accommodate Deno. Components can be installed as such (for example, for the accordion component):

```sh
deno task ui add accordion
```

# General Rules

## Correctness

* **Remove anything that isn‚Äôt used** ‚Äì delete unused imports, function parameters, and private class members.
* **Exhaust every hook dependency** ‚Äì always list *all* external values in React hook dependency arrays.
* **Keep hooks pure** ‚Äì call React hooks only at the top level of a component (never in loops, conditions, or nested functions).
* **Use only real selectors** ‚Äì in CSS, reference valid pseudo-classes, pseudo-elements, and type selectors only.

## Suspicious Code

* **Skip the ‚Äúany‚Äù shortcut** ‚Äì prefer precise TypeScript types.
* **Hands off `document.cookie`** ‚Äì manipulating cookies directly is forbidden. Use React Router's cookie utilities instead.

## Performance

* **Compile regexes once** ‚Äì declare regular expressions at module scope, not inside hot functions.

## Style & Consistency

* **Stick to ES modules** ‚Äì no `require` or other CommonJS patterns.
* **Prefer `import type`** ‚Äì separate type-only imports.
* **Use the `node:` protocol** ‚Äì write `import fs from 'node:fs'` rather than bare `'fs'`.
* **Arrays = `T[]`** ‚Äì use shorthand array syntax consistently.
* **Don‚Äôt reassign parameters** ‚Äì treat function arguments as read-only.
* **Favor `const`** ‚Äì use `const` over `let` whenever a binding never changes.
* **One `const` per line** ‚Äì declare variables individually.
* **Skip non-null assertions** ‚Äì rewrite code so `!` isn‚Äôt necessary.
* **Avoid `enum`** ‚Äì choose unions, objects, or literal types instead.
* **Stick with `trimStart/End`** ‚Äì don‚Äôt use `trimLeft/Right`.
* **Default parameters go last** ‚Äì never precede required params with optional ones.
* **Self-close when empty** ‚Äì use `<Component />` instead of `<Component></Component>` when there are no children.
* **No unused template literals** ‚Äì convert to quotes if you‚Äôre not interpolating.
* **Don‚Äôt write `substr`** ‚Äì use `slice` instead.
* **Flatten simple `if` chains** ‚Äì collapse `else { if ‚Ä¶ }` when feasible.
* **Export only the component** ‚Äì in React Router routes, export nothing except the component and the whitelisted helpers (`loader`, `action`, `meta`, etc.).
* **Keep member access simple** ‚Äì omit `public`, `private`, or `protected`. Use native JavaScript private properties (e.g. `#property`) when you need to make a property private.
* **Leverage `as const`** ‚Äì assert immutability where appropriate.
* **Kill useless `else` blocks** ‚Äì when the `if` branch returns or throws, omit the `else`.
