/** biome-ignore-all lint/suspicious/noExplicitAny: Needed for internal access */
import * as schema from "$db/schema.ts";
import { Command } from "@cliffy/command";
import { ensureDir } from "@std/fs";
import { join } from "@std/path";

interface DrizzleColumn {
    name: string;
    type: string;
    primaryKey?: boolean;
    notNull?: boolean;
    unique?: boolean;
    default?: any;
}

interface DrizzleTable {
    name: string;
    columns: DrizzleColumn[];
}

/**
 * Extracts table schema information from Drizzle table definitions
 */
function extractTableSchema(tableObj: any): DrizzleTable {
    const tableName = tableObj[Symbol.for("drizzle:Name")];
    const columns: DrizzleColumn[] = [];

    // Get column definitions from the table object
    const tableConfig = tableObj[Symbol.for("drizzle:Columns")];

    for (const [columnName, columnDef] of Object.entries(tableConfig)) {
        const col = columnDef as any;

        columns.push({
            name: columnName,
            type: col.getSQLType(),
            primaryKey: col.primary,
            notNull: col.notNull,
            unique: col.unique,
            default: col.default,
        });
    }

    return { name: tableName, columns };
}

/**
 * Generates CREATE TABLE SQL for a table schema
 */
function generateCreateTableSQL(table: DrizzleTable): string {
    const columnDefs = table.columns.map((col) => {
        let def = `"${col.name}" ${col.type}`;

        if (col.primaryKey) def += " PRIMARY KEY";
        if (col.notNull) def += " NOT NULL";
        if (col.unique && !col.primaryKey) def += " UNIQUE";
        if (col.default !== undefined) {
            def += ` DEFAULT ${typeof col.default === "string" ? `'${col.default}'` : col.default}`;
        }

        return def;
    });

    return `CREATE TABLE "${table.name}" (\n  ${columnDefs.join(",\n  ")}\n);`;
}

/**
 * Generates migration file content
 */
function generateMigrationFile(tables: DrizzleTable[]): string {
    const sqlStatements = tables.map((table) => generateCreateTableSQL(table));

    return `-- Migration generated on ${new Date().toISOString()}
-- Generated by custom Drizzle migration generator

${sqlStatements.join("\n\n")}
`;
}

/**
 * Main migration generation function
 */
async function generateMigrations(outputDir = "./drizzle"): Promise<void> {
    console.log("üîÑ Generating migrations from schema...");

    // Ensure migrations directory exists
    await ensureDir(outputDir);

    // Extract table schemas
    const tables: DrizzleTable[] = [];

    for (const [, exportValue] of Object.entries(schema)) {
        if (
            exportValue && typeof exportValue === "object" &&
            // @ts-ignore internal to Drizzle
            exportValue[Symbol.for("drizzle:Name")]
        ) {
            const tableSchema = extractTableSchema(exportValue);
            tables.push(tableSchema);
            console.log(`üìã Found table: ${tableSchema.name}`);
        }
    }

    if (tables.length === 0) {
        console.log("‚ö†Ô∏è  No tables found in schema");
        return;
    }

    // Generate timestamp for migration file
    const timestamp = new Date().toISOString().replace(/[-:T]/g, "").split(".")[0];
    const filename = `${timestamp}_initial_migration.sql`;
    const filepath = join(outputDir, filename);

    // Generate migration content
    const migrationContent = generateMigrationFile(tables);

    // Write migration file
    await Deno.writeTextFile(filepath, migrationContent);

    console.log(`‚úÖ Generated migration: ${filepath}`);
    console.log(`üìä Tables processed: ${tables.length}`);
}

await new Command()
    .name("generate-migrations")
    .description("Generate SQL migrations from Drizzle schema (mimics drizzle-kit generate)")
    .option("-o, --output <dir:string>", "Output directory for migrations", {
        default: "./drizzle",
    })
    .action(async (options: { output: string }) => {
        try {
            await generateMigrations(options.output);
        } catch (error) {
            console.error("‚ùå Migration generation failed:", (error as Error).message);
            Deno.exit(1);
        }
    })
    .parse(Deno.args);
