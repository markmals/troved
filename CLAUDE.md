# Contributor Guide

# Deno 2.x

## Environment Setup
- Always use Deno 2.x features and APIs
- Use deno.json/deno.jsonc for project configuration
- Never use or create package.json nor tsconfig.json
- Prefer Deno's built-in tools and packages over npm packages when available
- Use the `imports` files in deno.json for dependency management
- Always use explicit file extensions in imports (.ts, .tsx)

## Testing Requirements
- Run `deno task test` for unit tests
- Use Deno's built-in testing framework (Deno.test) for code that doesn't need to be run through the Vite plugin pipeline
- Use Vitest for code that needs to be run through the Vite plugin pipeline, for example React, Solid.js, Astro, or Svelte code
- For JavaScript framework components, use Testing Library (@testing-library/*)
- Ensure all new features include corresponding unit tests
- Mock external APIs

## Code Quality Checks
- Format code with `deno task check` before committing
- Run `deno task check` and fix all info, warnings, and errors
- Type-check with `deno task typecheck`
- Prefer `unknown` over `any` unless absolutely necessary
- Use JSDoc/TSDoc comments for public APIs
- Document important lines of code with a single line comment

## Common Commands
- Dev server: `deno task dev`
- Build: `deno task build`
- Test: `deno task test`
- Type check: `deno task typecheck`
- Lint: `deno task check`

## Import Guidelines
- Use bare specifiers with import map for external deps
- Prefer `jsr:@std/*` for standard library
- Use relative imports for local modules
- Prefer import aliases over relative imports for local modules
- Always include file extensions

## Security Best Practices
- Explicitly specify Deno permissions in scripts
- Never use --allow-all (-A) in production for user scripts (only for npm/jsr packages)
- Validate environment variables at startup using `@std/assert`

## Debugging Approach
- Use console.log with clear prefixes during development
- Check Deno permissions first when encountering errors
- Verify deno.json `imports` configuration for dependency issues

## Deno Issues

If you run into any Deno or Vite related issues that you cannot resolve, use the following commands to try resetting the cache:

```sh
find . -type d -name "node_modules" -exec rm -rf {} + && find . -type f -name "deno.lock" -delete
deno clean
deno install --allow-scripts
```

# shadcn/ui

## New UI Components

Use `@withsprinkles/shadcn-ui` for new UI components. They can be installed as such (for example, for the accordion component):

```sh
deno task ui add accordion
```

# React Router

## Critical Route Type Imports

- **Always** import route types from `./+types/[routeName]`
- **Never** use parent-relative paths like `../+types/[routeName]` or `../../+types/[routeName]`
- If you see missing type errors:
  - Run `deno task typecheck` to generate types
  - Or start the dev server, which auto-generates them
  - **Don’t** “fix” by editing the import path

```tsx
// ✅ Correct:
import type { Route } from "./+types/product-details";

// ❌ Incorrect:
import type { Route } from "../+types/product-details";
```

## Type Generation & Workflow

- Run `typecheck` after adding, renaming, or moving routes
- Types live in `./+types/[routeName]` and are generated by `@react-router/dev`
- The dev server will generate types automatically on startup

## Critical Package Guidelines

- ✅ **Use**
  - `react-router` (core routing)
  - `@react-router/dev` (dev tools & route config)
  - `@react-router/node` (Node.js adapter)
  - `@react-router/serve` (production server)
- ❌ **Avoid**
  - `react-router-dom` (legacy)
  - `@remix-run/*` (superseded)
  - Any React Router v6 patterns

## Essential Framework Architecture

- Define routes in `app/routes.ts` using `index()` and `route()` from `@react-router/dev/routes`
- Keep your route config the source of truth, not filenames
- Example:

```tsx
import { index, route } from "@react-router/dev/routes";

export default [
    index("routes/home.tsx"),
    route("products", "routes/products-layout.tsx", [
        index("routes/products-list.tsx"),
        route(":id", "routes/product-details.tsx"),
    ]),
];
```

## Route Module Pattern

- **Loader**: server-side data fetching
- **clientLoader**: client-side fetching for SPA navigation
- **action**: form submissions and mutations
- **default export**: your component, receiving `loaderData`

```tsx
import type { Route } from "./+types/product";

export async function loader({ params }: Route.LoaderArgs) {/*…*/}
export async function clientLoader({ serverLoader }: Route.ClientLoaderArgs) {/*…*/}
export async function action({ request }: Route.ActionArgs) {/*…*/}

export default function Product({ loaderData }: Route.ComponentProps) {
    return <div>{loaderData.product.name}</div>;
}
```

## Layout & Outlet Usage

- For parent routes, **always** render `<Outlet />` to display child routes
- **Do not** rely on children passed in props

```tsx
import { Outlet } from "react-router";
export default function CategoriesLayout() {
    return (
        <main>
            <Outlet />
        </main>
    );
}
```

## Automatic Type Safety & Generated Types

- ✅ **Always** import from `./+types/[routeName]`
- ✅ **Use** generated types for `LoaderArgs`, `ActionArgs`, `ComponentProps`, etc.
- If types are missing, run `deno task typecheck`—**don’t** hand-edit imports

```tsx
import type { Route } from "./+types/product-details";
```

## Type-Safe URL Generation

- Use `href()` for all links and redirects
- ✅ **Type-safe**:

```tsx
<Link to={href("/products/:id", { id: product.id })}>View</Link>;
return redirect(href("/products/:id", { id: newProduct.id }));
```

- ❌ **Avoid** manual string concatenation:

```tsx
// ❌
<Link to={`/products/${product.id}`}>View</Link>;
```

## Critical Imports & Patterns

- ✅ **Correct** imports:

```tsx
import { data, Form, href, Link, Outlet, redirect, useFetcher, useLoaderData } from "react-router";
import { index, route } from "@react-router/dev/routes";
```

## Data Loading & Actions

- **Server loader** for SSR/SSG
- **clientLoader** for SPA navigation (`clientLoader.hydrate = true`)
- Use `<Form>` and `action()` for submissions—**don’t** handle manually

## Navigation & Links

- Use `<Link>` and `<NavLink>`
- Programmatic nav via `useNavigate()`
- Prefetch/mutate with `useFetcher()`

## File Organization & Naming

- Organize by feature; use kebab-case (`product-details.tsx`)
- Route config defines paths—filenames are for clarity
- **Do** use descriptive names; **don’t** rely on file-based routing

## Error Handling & Boundaries

- Root `ErrorBoundary` catches most errors
- Add route-level boundaries only when custom UI needed

```tsx
export function ErrorBoundary({ error }: Route.ErrorBoundaryProps) {/*…*/}
```

- Throw errors with `data("Not Found", { status: 404 })`

## Advanced Patterns

- **Pending UI** with `useNavigation()`
- **Optimistic updates** using `fetcher.Form`

## Anti-Patterns to Avoid

- ❌ React Router v6 `<Routes><Route>` syntax
- ❌ Manual fetching in components—use loaders
- ❌ Manual form handling—use `Form` & `action`

## Essential Type Safety Rules

1. **Import** generated types from `./+types/[routeName]`
2. **Run** `deno task typecheck` on missing types
3. **Use** `href()` for URLs
4. **Let** TypeScript infer loader/action return types
5. **Use** `Route.ComponentProps` for components
6. **Include** `.react-router/types/**/*` in `tsconfig.json`

## AI Assistant Guidelines

- If a user reports missing `./+types` imports, **always** suggest `deno task typecheck`
- **Never** recommend changing the import path
- After new routes are created, remind to run `deno task typecheck`
